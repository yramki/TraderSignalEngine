#!/usr/bin/env python3
"""
Discord Trading Signal Scraper - All-In-One Installer and Setup Tool
This single file handles the complete installation, configuration, and setup of the application.
"""

import os
import sys
import platform
import subprocess
import configparser
import json
import shutil
import time
from pathlib import Path
import tempfile
import urllib.request
import webbrowser
try:
    import tkinter as tk
    from tkinter import ttk, messagebox, simpledialog
except ImportError:
    print("Installing Tkinter for UI...")
    if platform.system() == "Linux":
        subprocess.run(["apt-get", "update"], check=True)
        subprocess.run(["apt-get", "install", "-y", "python3-tk"], check=True)
    # Re-import after installation
    import tkinter as tk
    from tkinter import ttk, messagebox, simpledialog

# Configuration and constants
APP_NAME = "Discord Trading Signal Scraper"
APP_VERSION = "1.0.0"
PYTHON_MIN_VERSION = (3, 8)
REQUIRED_PACKAGES = [
    {"name": "customtkinter", "version": "5.2.0", "description": "Modern UI library"},
    {"name": "matplotlib", "version": "3.7.1", "description": "Data visualization"},
    {"name": "pandas", "version": "2.0.0", "description": "Data analysis"},
    {"name": "pyautogui", "version": "0.9.53", "description": "Screen automation"},
    {"name": "opencv-python", "version": "4.7.0.72", "description": "Computer vision"},
    {"name": "pytesseract", "version": "0.3.10", "description": "OCR tool"},
    {"name": "numpy", "version": "1.24.3", "description": "Numerical computation"},
    {"name": "Pillow", "version": "9.5.0", "description": "Image processing"},
    {"name": "requests", "version": "2.29.0", "description": "HTTP client"}
]

DEFAULT_CONFIG = {
    "General": {
        "debug_mode": "false",
        "scan_interval": "2.0",
        "test_mode": "true"
    },
    "Discord": {
        "monitor_enabled": "true",
        "click_hidden_messages": "true",
        "auto_scroll": "true",
        "scroll_interval": "30.0",
        "monitor_specific_channel": "true"
    },
    "Traders": {
        "enable_filtering": "true",
        "target_traders": "@example_trader"
    },
    "Phemex": {
        "api_key": "YOUR_API_KEY",
        "api_secret": "YOUR_API_SECRET",
        "testnet": "true"
    },
    "Trading": {
        "amount_per_trade": "100",
        "stop_loss_percentage": "5.0",
        "take_profit_percentage": "15.0",
        "min_market_cap": "10000000",
        "max_position_size": "1000",
        "default_leverage": "5",
        "enable_stop_loss": "true",
        "enable_take_profit": "true",
        "auto_trade": "false"
    }
}

APP_STRUCTURE = {
    "src": {
        "__init__.py": "",
        "main.py": "# Main application entry point\n# Imports and runs the application\n",
        "main_enhanced.py": "# Enhanced application with trader filtering\n",
        "screen_capture.py": "# Screen capture module\n",
        "signal_parser.py": "# Signal parsing module\n",
        "trading_client.py": "# Phemex API client\n",
        "config.py": "# Configuration handler\n",
        "ui": {
            "__init__.py": "",
            "main_window.py": "# Main window UI\n",
            "main_window_enhanced.py": "# Enhanced main window UI\n"
        }
    },
    "config": {
        "config.ini": "# Generated by installer\n"
    },
    "venv": {},
    "logs": {},
    "start.sh": "#!/bin/bash\nsource venv/bin/activate\npython src/main_enhanced.py\n",
    "README.md": "# Generated by installer\n"
}

# Documentation content
README_CONTENT = """# Discord Trading Signal Scraper

## Project Overview

Discord Trading Signal Scraper is a desktop application that captures trading signals from Discord and automatically executes trades on Phemex. The application uses screen scraping technology to detect and extract trading signals from your Discord window, then processes these signals to place trades on your Phemex account.

## Key Features

- **Screen Capture**: Monitors Discord for trading signals
- **Signal Parsing**: Extracts trading information from captured signals
- **Automated Trading**: Executes trades on Phemex based on signals
- **Trader Filtering**: Filter signals by specific traders
- **"Unlock Content" Detection**: Automatically clicks Discord's "Unlock Content" buttons
- **Continuous Monitoring**: Auto-scrolls to check for new messages
- **Risk Management**: Configurable position sizes and leverage
- **History Tracking**: Keep track of all signals and trades

## Key Trading Parameters

### Amount per Trade ($)
This determines how much USD value you wish to invest in each trade signal. The application will calculate the appropriate position size based on this amount and the current market price.

### Stop Loss (%)
Defines the percentage loss at which your position will automatically close to prevent further losses. For example, a 5% stop loss will close the trade if the price moves 5% against your position.

### Take Profit (%)
Defines the percentage gain at which your position will automatically close to secure profits. For example, a 15% take profit will close the trade once it reaches 15% profit.

### Minimum Market Cap ($)
This filter prevents trading on low-capitalization cryptocurrencies that may be too volatile or have low liquidity. Only cryptocurrencies with a market cap above this threshold will be considered for trading.

## Disclaimer

This application is for personal use only. Using automated tools with Discord may violate Discord's Terms of Service. Use at your own risk. The developers are not responsible for any losses incurred from trading or any account restrictions resulting from the use of this application.

Trading cryptocurrencies involves significant risk and can result in the loss of your invested capital. You should not invest more than you can afford to lose.
"""

class InstallationError(Exception):
    """Custom exception for installation errors."""
    pass

def check_python_version():
    """Check if the Python version meets requirements."""
    current_version = sys.version_info
    if current_version < PYTHON_MIN_VERSION:
        raise InstallationError(
            f"Python {PYTHON_MIN_VERSION[0]}.{PYTHON_MIN_VERSION[1]} or higher is required. "
            f"You are using Python {current_version.major}.{current_version.minor}.{current_version.micro}"
        )
    print(f"✓ Python version check passed: {current_version.major}.{current_version.minor}.{current_version.micro}")

def create_virtual_environment(install_dir):
    """Create a Python virtual environment."""
    venv_dir = os.path.join(install_dir, "venv")
    print(f"Creating virtual environment in {venv_dir}...")
    try:
        subprocess.run([sys.executable, "-m", "venv", venv_dir], check=True)
        print("✓ Virtual environment created successfully")
        return venv_dir
    except subprocess.CalledProcessError as e:
        raise InstallationError(f"Failed to create virtual environment: {e}")

def get_venv_python(venv_dir):
    """Get the path to the Python executable in the virtual environment."""
    if platform.system() == "Windows":
        return os.path.join(venv_dir, "Scripts", "python.exe")
    else:
        return os.path.join(venv_dir, "bin", "python")

def install_dependencies(venv_dir):
    """Install required Python packages."""
    venv_python = get_venv_python(venv_dir)
    pip_cmd = [venv_python, "-m", "pip", "install", "--upgrade", "pip"]
    try:
        print("Upgrading pip...")
        subprocess.run(pip_cmd, check=True)
        print("✓ Pip upgraded successfully")
        
        # Install each package
        for package in REQUIRED_PACKAGES:
            package_spec = f"{package['name']}=={package['version']}"
            print(f"Installing {package_spec}...")
            subprocess.run(
                [venv_python, "-m", "pip", "install", package_spec],
                check=True
            )
            print(f"✓ Installed {package_spec}")
        
        print("✓ All Python dependencies installed successfully")
    except subprocess.CalledProcessError as e:
        raise InstallationError(f"Failed to install dependencies: {e}")

def install_system_dependencies():
    """Install required system dependencies."""
    system = platform.system()
    if system == "Linux":
        try:
            print("Installing system dependencies for Linux...")
            subprocess.run(["apt-get", "update"], check=True)
            subprocess.run(["apt-get", "install", "-y", "tesseract-ocr", "tesseract-ocr-eng", "libgl1-mesa-glx"], check=True)
            print("✓ System dependencies installed successfully")
        except subprocess.CalledProcessError as e:
            raise InstallationError(f"Failed to install system dependencies: {e}")
    elif system == "Darwin":  # macOS
        try:
            # Check if Homebrew is installed
            result = subprocess.run(["which", "brew"], capture_output=True, text=True)
            if not result.stdout.strip():
                print("Homebrew not found. Please install Homebrew to continue.")
                print("Visit https://brew.sh for installation instructions.")
                user_input = input("Press Enter after installing Homebrew or type 'skip' to skip Tesseract installation: ")
                if user_input.lower() == "skip":
                    print("Skipping Tesseract OCR installation")
                    return
            
            print("Installing Tesseract OCR via Homebrew...")
            subprocess.run(["brew", "install", "tesseract"], check=True)
            print("✓ Tesseract OCR installed successfully")
        except subprocess.CalledProcessError as e:
            raise InstallationError(f"Failed to install Tesseract OCR: {e}")
    elif system == "Windows":
        print("Tesseract OCR needs to be installed manually on Windows.")
        print("Please visit: https://github.com/UB-Mannheim/tesseract/wiki")
        print("Download and install the latest version.")
        webbrowser.open("https://github.com/UB-Mannheim/tesseract/wiki")
        input("Press Enter after installing Tesseract OCR to continue...")
    else:
        print(f"Unsupported operating system: {system}")
        print("Please install Tesseract OCR manually.")

def create_app_structure(install_dir):
    """Create the application directory structure."""
    print(f"Creating application structure in {install_dir}...")
    try:
        for path, content in _walk_app_structure(APP_STRUCTURE, install_dir):
            if os.path.isdir(path):
                os.makedirs(path, exist_ok=True)
            else:
                os.makedirs(os.path.dirname(path), exist_ok=True)
                with open(path, 'w') as f:
                    f.write(content)
        
        # Make start script executable
        start_script = os.path.join(install_dir, "start.sh")
        if platform.system() != "Windows" and os.path.exists(start_script):
            os.chmod(start_script, 0o755)
        
        # Create README.md
        with open(os.path.join(install_dir, "README.md"), 'w') as f:
            f.write(README_CONTENT)
        
        print("✓ Application structure created successfully")
    except OSError as e:
        raise InstallationError(f"Failed to create application structure: {e}")

def _walk_app_structure(structure, base_path, current_path=""):
    """Helper function to walk through the app structure."""
    for name, content in structure.items():
        path = os.path.join(base_path, current_path, name)
        if isinstance(content, dict):
            yield path, None
            yield from _walk_app_structure(content, base_path, os.path.join(current_path, name))
        else:
            yield path, content

def create_config(install_dir):
    """Create the configuration file."""
    config_path = os.path.join(install_dir, "config", "config.ini")
    print(f"Creating configuration file at {config_path}...")
    try:
        config = configparser.ConfigParser()
        for section, options in DEFAULT_CONFIG.items():
            config[section] = options
        
        os.makedirs(os.path.dirname(config_path), exist_ok=True)
        with open(config_path, 'w') as configfile:
            config.write(configfile)
        
        print("✓ Configuration file created successfully")
    except (OSError, configparser.Error) as e:
        raise InstallationError(f"Failed to create configuration file: {e}")

def create_desktop_shortcut(install_dir):
    """Create a desktop shortcut for the application."""
    system = platform.system()
    home_dir = os.path.expanduser("~")
    desktop_dir = os.path.join(home_dir, "Desktop")
    
    if system == "Linux":
        shortcut_path = os.path.join(desktop_dir, f"{APP_NAME}.desktop")
        shortcut_content = f"""[Desktop Entry]
Name={APP_NAME}
Exec=bash -c "cd {install_dir} && ./start.sh"
Type=Application
Terminal=false
Icon=utilities-terminal
Comment=Discord Trading Signal Scraper
"""
        try:
            with open(shortcut_path, 'w') as f:
                f.write(shortcut_content)
            os.chmod(shortcut_path, 0o755)
            print(f"✓ Desktop shortcut created at {shortcut_path}")
        except OSError as e:
            print(f"Warning: Failed to create desktop shortcut: {e}")
    
    elif system == "Darwin":  # macOS
        shortcut_path = os.path.join(desktop_dir, f"{APP_NAME}.command")
        shortcut_content = f"""#!/bin/bash
cd "{install_dir}" && ./start.sh
"""
        try:
            with open(shortcut_path, 'w') as f:
                f.write(shortcut_content)
            os.chmod(shortcut_path, 0o755)
            print(f"✓ Desktop shortcut created at {shortcut_path}")
        except OSError as e:
            print(f"Warning: Failed to create desktop shortcut: {e}")
    
    elif system == "Windows":
        # Create a batch file shortcut
        shortcut_path = os.path.join(desktop_dir, f"{APP_NAME}.bat")
        shortcut_content = f"""@echo off
cd /d "{install_dir.replace('/', '\\')}"
venv\\Scripts\\python.exe src\\main_enhanced.py
"""
        try:
            with open(shortcut_path, 'w') as f:
                f.write(shortcut_content)
            print(f"✓ Desktop shortcut created at {shortcut_path}")
        except OSError as e:
            print(f"Warning: Failed to create desktop shortcut: {e}")
    
    else:
        print(f"Warning: Desktop shortcut creation not supported on {system}")

class InstallerApp(tk.Tk):
    """Graphical installer application."""
    
    def __init__(self):
        super().__init__()
        self.title(f"{APP_NAME} Installer")
        self.geometry("700x600")
        self.resizable(True, True)
        
        self.install_dir = os.path.join(os.path.expanduser("~"), APP_NAME.replace(" ", "_"))
        self.create_widgets()
    
    def create_widgets(self):
        """Create the installer UI widgets."""
        # Main frame
        main_frame = ttk.Frame(self, padding=20)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Header
        header_label = ttk.Label(
            main_frame, 
            text=f"{APP_NAME} v{APP_VERSION}", 
            font=("Helvetica", 16, "bold")
        )
        header_label.pack(pady=10)
        
        # Description
        desc_text = (
            "This installer will set up the Discord Trading Signal Scraper application on your computer. "
            "It will install all required dependencies, create configuration files, and set up shortcuts."
        )
        desc_label = ttk.Label(main_frame, text=desc_text, wraplength=650)
        desc_label.pack(pady=10)
        
        # Installation directory
        dir_frame = ttk.Frame(main_frame)
        dir_frame.pack(fill=tk.X, pady=10)
        
        dir_label = ttk.Label(dir_frame, text="Installation Directory:")
        dir_label.pack(side=tk.LEFT, padx=5)
        
        self.dir_entry = ttk.Entry(dir_frame, width=50)
        self.dir_entry.insert(0, self.install_dir)
        self.dir_entry.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        
        browse_btn = ttk.Button(dir_frame, text="Browse", command=self.browse_dir)
        browse_btn.pack(side=tk.LEFT, padx=5)
        
        # Trading Parameters Frame
        param_frame = ttk.LabelFrame(main_frame, text="Trading Parameters", padding=10)
        param_frame.pack(fill=tk.X, pady=10)
        
        # Trading Parameters
        self.create_parameter_entry(param_frame, "Amount per trade ($):", "amount_per_trade", DEFAULT_CONFIG["Trading"]["amount_per_trade"], 0)
        self.create_parameter_entry(param_frame, "Stop loss (%):", "stop_loss_percentage", DEFAULT_CONFIG["Trading"]["stop_loss_percentage"], 1)
        self.create_parameter_entry(param_frame, "Take profit (%):", "take_profit_percentage", DEFAULT_CONFIG["Trading"]["take_profit_percentage"], 2)
        self.create_parameter_entry(param_frame, "Min market cap ($):", "min_market_cap", DEFAULT_CONFIG["Trading"]["min_market_cap"], 3)
        
        # Phemex API Frame
        api_frame = ttk.LabelFrame(main_frame, text="Phemex API (Optional)", padding=10)
        api_frame.pack(fill=tk.X, pady=10)
        
        self.create_parameter_entry(api_frame, "API Key:", "api_key", DEFAULT_CONFIG["Phemex"]["api_key"], 0)
        self.create_parameter_entry(api_frame, "API Secret:", "api_secret", DEFAULT_CONFIG["Phemex"]["api_secret"], 1)
        
        # Checkboxes
        options_frame = ttk.Frame(main_frame)
        options_frame.pack(fill=tk.X, pady=10)
        
        self.create_desktop_var = tk.BooleanVar(value=True)
        create_desktop_cb = ttk.Checkbutton(
            options_frame, 
            text="Create Desktop Shortcut", 
            variable=self.create_desktop_var
        )
        create_desktop_cb.grid(row=0, column=0, sticky=tk.W, padx=5, pady=2)
        
        self.testnet_var = tk.BooleanVar(value=True)
        testnet_cb = ttk.Checkbutton(
            options_frame, 
            text="Use Phemex Testnet (recommended for testing)", 
            variable=self.testnet_var
        )
        testnet_cb.grid(row=1, column=0, sticky=tk.W, padx=5, pady=2)
        
        # Console output
        console_frame = ttk.LabelFrame(main_frame, text="Installation Log", padding=10)
        console_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        self.console = tk.Text(console_frame, height=10, width=80, bg="#f0f0f0")
        self.console.pack(fill=tk.BOTH, expand=True)
        
        # Redirect stdout to the console
        sys.stdout = TextRedirector(self.console)
        
        # Install button
        self.install_btn = ttk.Button(
            main_frame, 
            text="Install", 
            command=self.start_installation
        )
        self.install_btn.pack(pady=10)
        
        # Status label
        self.status_label = ttk.Label(main_frame, text="Ready to install", font=("Helvetica", 10))
        self.status_label.pack(pady=5)
    
    def create_parameter_entry(self, parent, label_text, param_name, default_value, row):
        """Create a parameter entry widget."""
        label = ttk.Label(parent, text=label_text)
        label.grid(row=row, column=0, sticky=tk.W, padx=5, pady=5)
        
        entry = ttk.Entry(parent, width=20)
        entry.insert(0, default_value)
        entry.grid(row=row, column=1, sticky=tk.W, padx=5, pady=5)
        
        setattr(self, f"{param_name}_entry", entry)
    
    def browse_dir(self):
        """Open directory browser dialog."""
        dir_path = tk.filedialog.askdirectory(initialdir=os.path.dirname(self.install_dir))
        if dir_path:
            self.install_dir = os.path.join(dir_path, os.path.basename(self.install_dir))
            self.dir_entry.delete(0, tk.END)
            self.dir_entry.insert(0, self.install_dir)
    
    def start_installation(self):
        """Start the installation process."""
        self.install_dir = self.dir_entry.get()
        self.install_btn.config(state=tk.DISABLED)
        self.status_label.config(text="Installing... Please wait")
        
        # Start installation in a separate thread
        self.after(100, self.run_installation)
    
    def run_installation(self):
        """Run the installation process."""
        try:
            # Create installation directory
            os.makedirs(self.install_dir, exist_ok=True)
            
            # Run installation steps
            check_python_version()
            install_system_dependencies()
            venv_dir = create_virtual_environment(self.install_dir)
            install_dependencies(venv_dir)
            create_app_structure(self.install_dir)
            
            # Update configuration with user inputs
            self.update_config()
            
            # Create desktop shortcut if requested
            if self.create_desktop_var.get():
                create_desktop_shortcut(self.install_dir)
            
            # Show success message
            self.status_label.config(text="Installation completed successfully!")
            messagebox.showinfo(
                "Installation Complete",
                f"{APP_NAME} has been installed successfully!\n\n"
                f"Location: {self.install_dir}\n\n"
                "You can start the application by running the 'start.sh' script "
                "or using the desktop shortcut if created."
            )
            
        except InstallationError as e:
            self.status_label.config(text=f"Installation failed: {e}")
            messagebox.showerror("Installation Error", str(e))
        except Exception as e:
            self.status_label.config(text=f"Unexpected error: {e}")
            messagebox.showerror("Unexpected Error", str(e))
        finally:
            self.install_btn.config(state=tk.NORMAL)
    
    def update_config(self):
        """Update the configuration with user inputs."""
        config_path = os.path.join(self.install_dir, "config", "config.ini")
        config = configparser.ConfigParser()
        
        # Load the default config first
        for section, options in DEFAULT_CONFIG.items():
            config[section] = options
        
        # Update with user inputs
        config["Trading"]["amount_per_trade"] = self.amount_per_trade_entry.get()
        config["Trading"]["stop_loss_percentage"] = self.stop_loss_percentage_entry.get()
        config["Trading"]["take_profit_percentage"] = self.take_profit_percentage_entry.get()
        config["Trading"]["min_market_cap"] = self.min_market_cap_entry.get()
        config["Phemex"]["api_key"] = self.api_key_entry.get()
        config["Phemex"]["api_secret"] = self.api_secret_entry.get()
        config["Phemex"]["testnet"] = str(self.testnet_var.get()).lower()
        
        # Write the updated config
        with open(config_path, 'w') as configfile:
            config.write(configfile)
        
        print(f"✓ Configuration updated with user settings")

class TextRedirector:
    """Redirect stdout to a tkinter Text widget."""
    
    def __init__(self, text_widget):
        self.text_widget = text_widget
        self.buffer = ""
    
    def write(self, string):
        self.buffer += string
        self.text_widget.insert(tk.END, string)
        self.text_widget.see(tk.END)
        self.text_widget.update_idletasks()
    
    def flush(self):
        pass

def main():
    """Main function to run the installer."""
    try:
        app = InstallerApp()
        app.mainloop()
    except Exception as e:
        print(f"Error starting installer: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()